<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Simulador Efeito Fotoelétrico - Estilo UFPA (Corrigido)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #1a1a1a; color: white; }
        
        /* Painel de Controle */
        #ui-container {
            position: absolute; top: 20px; left: 20px; width: 320px;
            /* Adicionando z-index alto para garantir que fique sobre o canvas */
            z-index: 100; 
            background: rgba(0, 0, 0, 0.85); padding: 20px; border-radius: 10px;
            border-left: 5px solid #00d2ff; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            /* Importante: permite interação com os elementos do painel */
            user-select: none;
        }
        #controls { margin-top: 15px; }
        
        h1 { margin: 0 0 5px 0; font-size: 22px; color: #00d2ff; }
        h2 { margin: 0 0 15px 0; font-size: 14px; color: #aaa; font-weight: normal; }
        
        .btn-group { display: flex; gap: 10px; margin-bottom: 15px; }
        button {
            flex: 1; padding: 10px; border: none; border-radius: 5px; cursor: pointer;
            font-weight: bold; transition: 0.2s; color: white;
        }
        .btn-canudo { background: #ff4444; }
        .btn-canudo:hover { background: #cc3333; }
        .btn-lampada { background: #8a2be2; } /* Roxo UV */
        .btn-lampada:hover { background: #6a1b9a; }
        
        .ativo { border: 2px solid white; box-shadow: 0 0 10px white; }

        input[type=range] { width: 100%; cursor: pointer; margin: 10px 0; }
        
        #status-box {
            margin-top: 20px; padding: 10px; background: #222; border-radius: 5px;
            font-size: 14px; line-height: 1.4; color: #ffcc00; min-height: 60px;
        }
        /* Instruções de câmera */
        .cam-instructions { font-size: 11px; color: #777; margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="ui-container">
        <h1>Laboratório Virtual IFPA</h1>
        <h2>Experimento 2: O Efeito Fotoelétrico</h2>
        
        <div id="controls">
            <p>1. Escolha a Ferramenta:</p>
            <div class="btn-group">
                <button id="btnCanudo" class="btn-canudo" onclick="selecionarFerramenta('canudo')"> CANUDO (Carregar)</button>
                <button id="btnLampada" class="btn-lampada" onclick="selecionarFerramenta('lampada')"> LUZ UV (Descarregar)</button>
            </div>

            <p>2. Aproxime da Placa:</p>
            <input type="range" id="sliderDistancia" min="0" max="100" value="0" 
                   onmousedown="event.stopPropagation()" 
                   ontouchstart="event.stopPropagation()">
            
            <div id="status-box">Selecione uma ferramenta para começar o experimento.</div>
        </div>
        <div class="cam-instructions">
             Arraste no fundo para girar.<br>
             Use a rodinha para Zoom.
        </div>
    </div>

    <script>
        // --- CENÁRIO 3D ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x202020);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 7); // Câmera um pouco mais longe

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        // Importante: O canvas deve ficar atrás da UI
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.zIndex = '0';
        document.body.appendChild(renderer.domElement);

        // --- CONTROLES DE CÂMERA (OrbitControls - CORREÇÃO DO PROBLEMA) ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Movimento suave
        controls.dampingFactor = 0.05;
        controls.target.set(0, 2, 0); // A câmera olha para o meio do pote
        controls.update();

        // Luzes
        const ambLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambLight);
        const spotLight = new THREE.SpotLight(0xffffff, 1);
        spotLight.position.set(5, 10, 8);
        spotLight.castShadow = true;
        scene.add(spotLight);

        // --- OBJETOS ---
        
        // Pote (Vidro)
        const vidroMat = new THREE.MeshPhongMaterial({ color: 0xaaddff, opacity: 0.2, transparent: true, shininess: 100, side: THREE.DoubleSide });
        const pote = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 3, 32, 1, true), vidroMat);
        pote.position.y = 1.5;
        scene.add(pote);

        // Tampa
        const tampa = new THREE.Mesh(new THREE.CylinderGeometry(1.1, 1.1, 0.2, 32), new THREE.MeshStandardMaterial({ color: 0xdddddd }));
        tampa.position.y = 3.1;
        scene.add(tampa);

        // Haste de Cobre
        const haste = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 3, 16), new THREE.MeshStandardMaterial({ color: 0xb87333, metalness: 0.8, roughness: 0.2 }));
        haste.position.y = 2;
        scene.add(haste);

        // Placa de Zinco (CORREÇÃO DE COR)
        // Cor alterada para um cinza mais fosco (0x888888) e menos metálico
        const zincoMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.5, roughness: 0.6 });
        const zinco = new THREE.Mesh(new THREE.BoxGeometry(1, 0.05, 1), zincoMat);
        zinco.position.y = 3.55;
        scene.add(zinco);

        // Folhas (Antenas)
        const folhaGeo = new THREE.BoxGeometry(0.02, 1.2, 0.3);
        const folhaMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8 });

        const pivoEsq = new THREE.Object3D();
        pivoEsq.position.set(0, 1.0, 0);
        const folhaEsq = new THREE.Mesh(folhaGeo, folhaMat);
        folhaEsq.position.y = -0.5; 
        pivoEsq.add(folhaEsq);
        scene.add(pivoEsq);

        const pivoDir = new THREE.Object3D();
        pivoDir.position.set(0, 1.0, 0);
        const folhaDir = new THREE.Mesh(folhaGeo, folhaMat);
        folhaDir.position.y = -0.5;
        pivoDir.add(folhaDir);
        scene.add(pivoDir);

        // FERRAMENTA 1: Canudo
        const canudoObj = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 3, 32), new THREE.MeshStandardMaterial({ color: 0xff3333 }));
        canudoObj.rotation.z = Math.PI / 2;
        canudoObj.position.set(-5, 4, 0);
        scene.add(canudoObj);

        // FERRAMENTA 2: Lâmpada UV
        const lampadaGroup = new THREE.Group();
        const bulbo = new THREE.Mesh(new THREE.SphereGeometry(0.4, 32, 32), new THREE.MeshStandardMaterial({ color: 0x220044, emissive: 0x4b0082, emissiveIntensity: 2 }));
        const baseLamp = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.5, 32), new THREE.MeshStandardMaterial({ color: 0x888888 }));
        baseLamp.rotation.z = Math.PI / 2;
        baseLamp.position.x = 0.5;
        lampadaGroup.add(bulbo);
        lampadaGroup.add(baseLamp);
        const luzUV = new THREE.PointLight(0x8a2be2, 0, 5);
        lampadaGroup.add(luzUV);
        lampadaGroup.position.set(-5, 4, 0);
        scene.add(lampadaGroup);

        // --- LÓGICA DO EXPERIMENTO ---
        let cargaAtual = 0;
        let ferramentaAtiva = null;
        
        const slider = document.getElementById('sliderDistancia');
        const statusBox = document.getElementById('status-box');

        function selecionarFerramenta(tipo) {
            ferramentaAtiva = tipo;
            slider.value = 0;
            document.getElementById('btnCanudo').classList.remove('ativo');
            document.getElementById('btnLampada').classList.remove('ativo');
            
            if (tipo === 'canudo') {
                document.getElementById('btnCanudo').classList.add('ativo');
                canudoObj.visible = true; lampadaGroup.visible = false;
                statusBox.innerHTML = "<b>Ferramenta: CANUDO</b><br>Aproxime para repelir elétrons e carregar.";
                statusBox.style.color = "#ffaaaa";
            } else {
                document.getElementById('btnLampada').classList.add('ativo');
                canudoObj.visible = false; lampadaGroup.visible = true;
                statusBox.innerHTML = "<b>Ferramenta: LÂMPADA UV</b><br>Aproxime para arrancar elétrons (Efeito Fotoelétrico).";
                statusBox.style.color = "#ddaaff";
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Atualiza os controles de câmera

            const dist = slider.value / 100;
            const targetX = -4 + (dist * 3.5);

            if (ferramentaAtiva === 'canudo') {
                canudoObj.position.x = targetX;
                if (dist > 0.8) {
                    if (cargaAtual < 1) cargaAtual += 0.05;
                    statusBox.innerHTML = "⚡ <b>CARREGANDO(inducao eletrostatica)!</b><br>Folhas se abrindo por repulsão.";
                }
            } else if (ferramentaAtiva === 'lampada') {
                lampadaGroup.position.x = targetX;
                if (dist > 0.1) {
                    luzUV.intensity = 5; bulbo.material.emissiveIntensity = 3;
                } else {
                    luzUV.intensity = 0; bulbo.material.emissiveIntensity = 0.5;
                }
                if (dist > 0.7 && cargaAtual > 0) {
                    cargaAtual -= 0.1;
                    if (cargaAtual < 0) cargaAtual = 0;
                    statusBox.innerHTML = " <b>EFEITO FOTOELÉTRICO!</b><br>Elétrons arrancados! Descarregando...";
                }
            }

            const angulo = cargaAtual * 1.0;
            pivoEsq.rotation.z = THREE.MathUtils.lerp(pivoEsq.rotation.z, angulo, 0.1);
            pivoDir.rotation.z = THREE.MathUtils.lerp(pivoDir.rotation.z, -angulo, 0.1);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>